# C++ 表达式/运算符/自动类型转换

## 1. 表达式相关概念

### 1.1 n-ary operator

### 1.2 运算对象转换（见后文）

### 1.3 重载运算符

+ 可以改变：
  + 运算对象类型
  + 返回值类型
+ 不可改变：
  + 运算对象个数
  + 运算符优先级
  + 结合律

### 1.4 左值与右值（概括）

+ 简单概括：
  + 使用 rvalue 时，使用的是对象的值（内容）
  + 使用 lvalue 时，使用的是对象的身份（在内存的位置）
  + lvalue 可作为 rvalue 使用，反之不可以
+ 使用例
  + 赋值需要左值，得到左值
  + 取地址需要左值，返回右值
  + 解引用、下标运算符、迭代器解引用等，得到左值
  + 内置类型与迭代器自增自减，得到左值
+ 与 decltype 的使用
  + 设 int *p = nullptr;
  + 对得到左值的表达式，decltype 得到引用
    + 如，decltype(*p) 是 int&
  + 否则，得到对应类型
    + 如，decltype(&p) 是 int **

### 1.5 求值顺序

+ 大多情况不会明确求值顺序，如 int i = f1() * f2();
+ 此时如果表达式指向且修改同一个变量，结果是未定义的
  + 如：cout << i << i++
  + 如：f1() + f2() * f3() 当 f1 f2 f3 都修改相同对象时
+ 明确顺序的运算符：
  + && || , :?
+ 总结：改变了某个运算对象的值，在表达式的其他地方最好不要用这个值
  + 除非改变运算对象的子表达式本身就是另一个子表达式的运算对象，如 *++iter

---

## 2. 算数运算符

+ \+ 或 - 或 \* 或 / 等
+ 返回值为 rvalue
+ 自动类型转换 同 C

### 2.1 注意事项

+ bool 值不应参与运算，bool 只要不是 0 就是 true
  + bool b = true;
  + bool b2 = -b;     // 还是 true
+ 除法一律向 0 取整 (C++11后)
+ & 与 * 的 const 性质取决于变量本身

```c++
int i = 0;
const int ci = 0;

std::cout << typeid(decltype(&i)).name() << std::endl;
std::cout << typeid(decltype(&ci)).name() << std::endl;

// out: Pi, Pki
```

---

## 3. 逻辑运算符

+ 短路求值
+ 比较时，若对象不是 bool ，则不要与 true / false 比较

---

## 4. 赋值运算符

+ 赋值运算 的 结果 是 其左值的类型

### 4.1 赋值与类型转换

+ 类型不同时，发生类型转换
  + 如，int k = 3.14;
+ C++ 11 后允许初始值列表初始化
  + 如，k = {3};
  + 但此时不允许窄化转换，如 k = {3.14};
+ 对于类类型，如 vector 重载了 赋值运算符
  + 因此可以直接接受初始值列表
  + 此时用右值替换左侧元素的值
+ 初始值列表可以是空，此时编译器创建一个值初始化的临时量给左侧

### 4.2 赋值与结合律

+ 满足 右结合律，返回值为右侧对象，因此可以连续进行
  + 如，str1 = str2 = "OK";
  + 但必须局限于同类型，如 intK = ptrP = nullptr; // 不可以

### 4.3 复合赋值

+ 如，+= -= *= /= %= >>= <<= &= ^= |=
+ 可以减少临时变量的产生

### 4.4 自增运算符

| 特性     | 前置运算               | 后置运算                     |
| -------- | ---------------------- | ---------------------------- |
| 写法     | ++i                    | i++                          |
| 结果     | 递增后的值             | 递增前的值                   |
| 返回结果 | 将对象本身作为左值返回 | 将原始对象的副本作为右值返回 |

+ 尽量减少 后置++ 的使用，减少副本的开销
  + 例外：cout << *ptr++ << endl;

#### 4.4.1 求值顺序

+ 同上，不要同时修改 + 引用 同时出现
  + 如，\*ptr = toupper(\*(ptr++));
    + 可能的结果
    + \*beg = toupper(\*beg);
    + \*(beg + 1) = toupper(\*beg);

## 5. 条件运算符

+ 嵌套条件运算符：
  + finalgrade = (grade > 90) ? "excellent" : (grade > 60) ? "pass" : "fail";
+ 条件运算符的运算优先级很低
  + cout << grade < 60;   // 错误，试图比较 cout 和 60
  + cout << (grade < 60); // 正确

## 6. 位运算符

+ 一般建议用于 unsigned
+ 对于 signed 没有明确标准指定如何操作
+ 运行原理
  + 按照右侧要求移动 n 位（必须 n > 0 且没有超出左侧位数，否则==未定义==）
  + (optional) 提升数据类型
  + 将运算结果的拷贝作为求值结果

## 7. sizeof 运算符

### 7.1 使用方法

+ sizeof(type) 求类型的大小
+ sizeof expr 求表达式结果类型的大小
  + sizeof 的运算优先级高于一些表达式
  + 如 sizeof a + b 会结合成 (sizeof a) + b

### 7.2 返回值

+ size_t 类型
+ sizeof 不计算对象
  + 因此，sizeof 未初始化的指针可行
+ sizeof vector/string 只返回类型固定部分的大小，不计算实际元素占用大小

## 8. 逗号运算符

+ 含有两个对象，从左向右求值
+ 丢弃左侧运算的结果，最终结果为右侧值
+ 若右侧计算结果为 lvalue，那么结果就是 lvalue

## 9. 类型转换

### 9.1 隐式转换

+ 例：int i = 3.14 + 4;
  + 先把 4 提升为 double
  + 计算出 7.14 (double)
  + 赋值时，转换为 int

### 9.2 发生 implicit conversion 的条件

+ 比 int 小自动提升为 int
  + ==**注意，并非一步到位**==
  + 如，charval + doubleval 时，先转换一次 int，再转换一次 double
+ ==**unsigned 与 signed 同大小时，运算自动转换为 unsigned**==
  否则，转换为大的类型
+ 非 bool 自动转换为 bool
  + 只取决于是不是 0 (或 nullptr)
+ 类类型转换
  + 取决于类的定义

### 9.3 显式转换

+ 一般形式：cast-name\<type>(expression)
  + type 是 转换目标类型
    + 若 type 是 引用类型，则结果是左值
  + cast-name 是 转换方式
    + static_cast
      + 直接类型转换
    + const_cast
      + ==只能修改pointer==
      + 去处底层 const 的转换
      + 不可用于修改 const 变量本身的属性
    + reinterpret_cast
      + 重新解释变量的位组合，非常危险
      + 极度依赖于机器与编译器本身，需要了解

+ C 风格转换
  + 不推荐，不如新版清楚

+ 运算符优先级表
  + 见 <C++ Primer> P147 (PDF P173)

### 9.4 查看类型

+ 引入 \<typeinfo>
+ 定义 std::typeinfo& xxx = typeid(...)
+ 查看名称 cout << xxx.name() // C 风格字符串
